<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Webcam → Object → ASCII</title>
  <style>
    :root { color-scheme: dark light; }
    body {
      margin: 0; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      background: #0b0c10; color: #e6edf3; display: grid; min-height: 100vh; 
      grid-template-rows: auto 1fr auto;
    }
    header, footer { padding: 12px 16px; background: #0f1115; border-bottom: 1px solid #20232b; }
    footer { border-top: 1px solid #20232b; border-bottom: none; font-size: 12px; opacity: 0.8; }
    main { display: grid; gap: 16px; padding: 16px; grid-template-columns: 1fr 1fr; }
    .panel { background: #0f1115; border: 1px solid #20232b; border-radius: 12px; padding: 12px; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    video, canvas { width: 100%; border-radius: 10px; background: #000; }
    #asciiOut {
      white-space: pre; font-size: 10px; line-height: 10px; 
      letter-spacing: 0px; overflow: auto; max-height: 70vh; background: #000; 
      border-radius: 10px; padding: 8px;
    }
    button, select, input[type="checkbox"] + label, input[type="range"] {
      font: inherit; color: inherit;
    }
    button {
      padding: 8px 12px; background: #1f6feb; color: #fff; border: 0; border-radius: 8px; cursor: pointer;
    }
    button:disabled { opacity: .6; cursor: not-allowed; }
    .muted { opacity: .8; }
    .pill { padding: 2px 8px; border: 1px solid #2a2f3a; border-radius: 999px; font-size: 12px; }
    .stack { display: grid; gap: 8px; }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .small { font-size: 12px; opacity: .8; }
    .bar { height: 6px; background: #1b1f27; border-radius: 999px; overflow: hidden; }
    .bar > div { height: 100%; width: 0%; background: #1f6feb; transition: width .3s ease; }
    @media (max-width: 900px) {
      main { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <div class="row">
      <strong>Webcam → Object → ASCII</strong>
      <span class="pill" id="modelStatus">Loading model…</span>
      <span class="pill" id="camStatus">Camera: not started</span>
    </div>
  </header>

  <main>
    <section class="panel stack">
      <div class="grid2">
        <div class="stack">
          <video id="video" autoplay playsinline muted></video>
          <div class="row">
            <button id="startBtn">Start camera</button>
            <button id="snapBtn" disabled>Snapshot → ASCII</button>
            <button id="detectBtn" disabled>Detect only</button>
          </div>
        </div>
        <div class="stack">
          <canvas id="draw" hidden></canvas>
          <div class="stack">
            <div class="row">
              <label class="small muted">ASCII width (chars): <span id="wVal">80</span></label>
              <input id="asciiWidth" type="range" min="40" max="180" value="80" />
            </div>
            <div class="row">
              <input id="mirror" type="checkbox" />
              <label for="mirror">Mirror preview</label>
              <input id="showBoxes" type="checkbox" checked />
              <label for="showBoxes">Show boxes on detect</label>
            </div>
            <div class="row small muted">
              Charset:
              <select id="charset">
                <option value=" .:-=+*#%@">Ramp (light→dark)</option>
                <option value=" .'`^\",:;Il!i><~+_-?][}{1)(|\\/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$">Detailed</option>
                <option value="@%#*+=-:. ">Inverse</option>
                <option value="01">Binary</option>
                <option value=" .oO#">Dots</option>
              </select>
            </div>
            <div class="bar" aria-hidden="true"><div id="prog"></div></div>
            <div id="label" class="small muted">Ready.</div>
          </div>
        </div>
      </div>
    </section>

    <section class="panel stack">
      <div class="row"><strong>ASCII Output</strong> <span class="pill" id="detMeta">—</span></div>
      <pre id="asciiOut">(ascii will appear here)</pre>
    </section>
  </main>

  <footer>
    Works locally over HTTPS. Uses TensorFlow.js COCO-SSD for detection (no face recognition, only “person” class).
  </footer>

  <!-- TensorFlow.js + COCO-SSD -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js" crossorigin="anonymous"></script>

  <script>
  (() => {
    const video = document.getElementById('video');
    const startBtn = document.getElementById('startBtn');
    const snapBtn = document.getElementById('snapBtn');
    const detectBtn = document.getElementById('detectBtn');
    const asciiOut = document.getElementById('asciiOut');
    const draw = document.getElementById('draw');
    const asciiWidth = document.getElementById('asciiWidth');
    const wVal = document.getElementById('wVal');
    const labelEl = document.getElementById('label');
    const prog = document.getElementById('prog');
    const charsetSel = document.getElementById('charset');
    const modelStatus = document.getElementById('modelStatus');
    const camStatus = document.getElementById('camStatus');
    const mirror = document.getElementById('mirror');
    const showBoxes = document.getElementById('showBoxes');
    const detMeta = document.getElementById('detMeta');

    let model = null;
    let stream = null;

    // Smooth progress helper
    const setProgress = (p) => { prog.style.width = `${Math.max(0, Math.min(100, p))}%`; };

    // Load model ASAP
    (async () => {
      try {
        setProgress(10);
        model = await cocoSsd.load({ base: 'lite_mobilenet_v2' });
        modelStatus.textContent = 'Model: loaded';
        setProgress(100);
        setTimeout(() => setProgress(0), 400);
      } catch (err) {
        modelStatus.textContent = 'Model: failed to load';
        console.error(err);
      }
      updateButtons();
    })();

    function updateButtons() {
      const camReady = !!stream;
      const mdlReady = !!model;
      startBtn.disabled = camReady;
      snapBtn.disabled = !(camReady && mdlReady);
      detectBtn.disabled = !(camReady && mdlReady);
    }

    // Start camera
    startBtn.addEventListener('click', async () => {
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: false
        });
        video.srcObject = stream;
        await video.play();
        camStatus.textContent = 'Camera: running';
        updateButtons();
      } catch (err) {
        camStatus.textContent = 'Camera: permission denied or unavailable';
        console.error(err);
      }
    });

    // Mirror toggle
    mirror.addEventListener('change', () => {
      video.style.transform = mirror.checked ? 'scaleX(-1)' : 'none';
    });

    asciiWidth.addEventListener('input', () => { wVal.textContent = asciiWidth.value; });

    // Detect button: just draw boxes + label
    detectBtn.addEventListener('click', async () => {
      if (!model || !stream) return;
      labelEl.textContent = 'Detecting…';
      const { detections, best } = await detectFrame();
      drawBoxes(detections);
      updateDetMeta(best, detections.length);
      labelEl.textContent = best ? `Detected: ${best.class} (${(best.score*100).toFixed(1)}%)` : 'No confident detections.';
    });

    // Snapshot → detect → ASCII
    snapBtn.addEventListener('click', async () => {
      if (!model || !stream) return;
      labelEl.textContent = 'Detecting…';
      setProgress(25);
      const { detections, best, frameCanvas } = await detectFrame(true);
      drawBoxes(detections);
      updateDetMeta(best, detections.length);
      if (!best) {
        asciiOut.textContent = '(No confident detection. Try again.)';
        setProgress(0);
        labelEl.textContent = 'No confident detections.';
        return;
      }
      setProgress(60);
      const ascii = await cropAndAscii(frameCanvas, best.bbox, parseInt(asciiWidth.value, 10), charsetSel.value);
      asciiOut.textContent = ascii;
      setProgress(0);
      labelEl.textContent = `ASCII generated for “${best.class}”.`;
    });

    function updateDetMeta(best, count) {
      if (!best) {
        detMeta.textContent = 'No detection';
        return;
      }
      const [x, y, w, h] = best.bbox.map(n => Math.round(n));
      detMeta.textContent = `${best.class} ${(best.score*100).toFixed(0)}% • bbox ${w}×${h} @ (${x},${y}) • total: ${count}`;
    }

    async function detectFrame(returnFrame = false) {
      // Draw current video frame to an offscreen canvas
      const tmp = document.createElement('canvas');
      const vw = video.videoWidth, vh = video.videoHeight;
      tmp.width = vw; tmp.height = vh;
      const ctx = tmp.getContext('2d', { willReadFrequently: true });

      if (mirror.checked) {
        ctx.translate(vw, 0);
        ctx.scale(-1, 1);
      }
      ctx.drawImage(video, 0, 0, vw, vh);

      // Run detection
      const predictions = await model.detect(tmp);
      // Filter by score threshold
      const good = predictions.filter(p => p.score >= 0.5);

      // Choose best: prefer specific objects; fallback to largest area
      let best = null;
      if (good.length) {
        // Heuristic: choose highest score; if tie, largest area
        best = good.slice().sort((a, b) => {
          if (b.score !== a.score) return b.score - a.score;
          const areaA = a.bbox[2]*a.bbox[3], areaB = b.bbox[2]*b.bbox[3];
          return areaB - areaA;
        })[0];
      }

      return { detections: good, best, frameCanvas: returnFrame ? tmp : null };
    }

    function drawBoxes(detections) {
      const vw = video.videoWidth, vh = video.videoHeight;
      if (!vw || !vh) return;
      draw.width = vw; draw.height = vh;
      const ctx = draw.getContext('2d');
      draw.hidden = false;

      // Background as semi-transparent overlay of current frame
      ctx.drawImage(video, 0, 0, vw, vh);
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(0, 0, vw, vh);

      if (!showBoxes.checked) {
        ctx.clearRect(0, 0, vw, vh);
        return;
      }

      for (const p of detections) {
        const [x, y, w, h] = p.bbox;
        ctx.strokeStyle = '#1f6feb';
        ctx.lineWidth = 3;
        ctx.strokeRect(x, y, w, h);

        const tag = `${p.class} ${(p.score*100).toFixed(0)}%`;
        ctx.font = '16px ui-monospace, monospace';
        const pad = 6;
        const textW = ctx.measureText(tag).width + pad*2;
        const textH = 20 + pad*2;
        ctx.fillStyle = 'rgba(15,17,21,0.9)';
        ctx.fillRect(x, y - textH, textW, textH);
        ctx.fillStyle = '#e6edf3';
        ctx.fillText(tag, x + pad, y - pad);
      }
    }

    async function cropAndAscii(sourceCanvas, bbox, outWidthChars = 80, charset = " .:-=+*#%@") {
      const [bx, by, bw, bh] = bbox.map(n => Math.max(0, Math.floor(n)));
      const sx = Math.min(bx, sourceCanvas.width - 1);
      const sy = Math.min(by, sourceCanvas.height - 1);
      const sw = Math.min(bw, sourceCanvas.width - sx);
      const sh = Math.min(bh, sourceCanvas.height - sy);

      // Crop to bbox
      const crop = document.createElement('canvas');
      crop.width = sw; crop.height = sh;
      const cctx = crop.getContext('2d', { willReadFrequently: true });
      cctx.drawImage(sourceCanvas, sx, sy, sw, sh, 0, 0, sw, sh);

      // Target ASCII grid size (adjust height for character aspect ratio)
      const charAspect = 2.0; // approx: characters are taller than they are wide
      const outW = outWidthChars;
      const outH = Math.max(12, Math.round((sh / sw) * outW / charAspect));

      // Scale to small canvas
      const small = document.createElement('canvas');
      small.width = outW;
      small.height = outH;
      const sctx = small.getContext('2d', { willReadFrequently: true, alpha: false });
      sctx.drawImage(crop, 0, 0, outW, outH);

      const { data } = sctx.getImageData(0, 0, outW, outH);
      const chars = charset;
      const n = chars.length - 1;

      // Build ASCII rows
      let out = '';
      for (let y = 0; y < outH; y++) {
        let row = '';
        for (let x = 0; x < outW; x++) {
          const idx = (y*outW + x)*4;
          const r = data[idx], g = data[idx+1], b = data[idx+2];
          // Perceived luminance
          const lum = 0.2126*r + 0.7152*g + 0.0722*b;
          const t = lum / 255;               // 0..1
          const ci = Math.round((1 - t) * n); // invert so dark→dense char
          row += chars[ci];
        }
        out += row + '\n';
      }
      return out;
    }

    // Clean up on unload
    window.addEventListener('beforeunload', () => {
      if (stream) stream.getTracks().forEach(t => t.stop());
    });
  })();
  </script>
</body>
</html>
